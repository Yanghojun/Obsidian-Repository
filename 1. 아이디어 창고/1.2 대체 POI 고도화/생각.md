ì‹œë‚˜ë¦¬ì˜¤
	ì„ íƒí•œ POIì™€ ìœ ì‚¬í•œ POIë¥¼ ì¶”ì²œ
		1. í˜„ì¬ ì„ íƒí•œ POI ì •ë³´
		2. User ê°œì¸ ì„ í˜¸ ì •ë³´
		3. ë‚˜ì™€ ë¹„ìŠ·í•œ ë‹¤ë¥¸ User ë“¤ì˜ ë°©ë¬¸ ì •ë³´
	ì˜ˆìƒë˜ëŠ” ë‹¨ì 
		Cold start: ë‚˜ì™€ ë¹„ìŠ·í•œ ì„ í˜¸ë¥¼ ê°–ëŠ” userì˜ ë¶€ì¡±

Trajectory ëª¨ë¸ë§ì´ í•„ìš”í• ê¹Œ?
	ìŒì‹ì  ì¶”ì²œì„ ìƒê°í•´ë´¤ì„ë•Œ, ìœ ì €ì˜ ì„ í˜¸ë¥¼ ê²°ì •í•  ë• ìœ ì €ê°€ ì–´ë–¤ ìŒì‹ì ë“¤ì„ ê°”ëŠ”ì§€ Pin ê¼½ìœ¼ë©´ ëŒ. SequenceëŠ” ì˜ë¯¸ ì—†ìŒ. Sequenceê°„ ìœ ì‚¬í•œ ìŒì‹ì ì„ ê°€ì§€ë„ ì•Šì„ê²ƒì´ê³ .

# ìš°ë¦¬ê°€ ê°€ì§„ ë°ì´í„°ë¡œ ë­˜ í•  ìˆ˜ ìˆë‚˜?
- ë¬¸ì œ ì •ì˜ë¥¼ ìœ„í•´ ìƒê°í•´ë³´ì.
User(ìš´ì „ì) - Item(POI)ê°„ Adjacency Matrix
	Userìˆ˜, Item ìˆ˜, Interactionìˆ˜ ë³´ë©´ ì–¼ë§ˆë‚˜ Sparseí•œì§€ ì•Œ ìˆ˜ ìˆì„ê²ƒ.

POI Feature. ì§€ë¦¬ì  ìœ„ì¹˜, ì¹´í…Œê³ ë¦¬, cb, cc, cd ë²”ì£¼
User Feature. ì‚¬ìš©í•  ë§Œí•œê²Œ ìˆë‚˜..?


# ì ìš©í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€ ë­ê°€ ìˆì„ê¹Œ?
- Contents based filtering
	- KG ê·¸ë˜í”„ (Metapath2vec)
		- POI - META
- Collaborative based filteirng
	- NGCF (Neural graph collaborative filtering)
		- User - POI Interaction

- Hybrid ì¶”ì²œ
	- NGCF + MLP
		- User-POI Interactionê³¼ POI categoryì •ë³´ë¥¼ MLPë¡œ ë„£ìœ¼ë©´ ë˜ì§€ ì•Šì„ê¹Œ?
	- KG ê·¸ë˜í”„ (Metapath2vec)
		- USER - POI - META - POI - USER
			- **ì´ê²Œ user ë°©ë¬¸ ì •ë³´, POI ë©”íƒ€ ì •ë³´ë¥¼ ëª¨ë‘ ì´ìš©í•œ ì¶”ì²œ ê²°ê³¼ì¼í…ë°..** ì´ìƒí•˜ì§€ ì•Šì„ê¹Œ..?
			- í•™ìŠµí•  ë•Œ user ë°©ë¬¸ ì •ë³´, POI ë©”íƒ€ ì •ë³´ë¥¼ ëª¨ë‘ ì‚¬ìš©í•œ ê²ƒì€ ë§ìŒ
	- ìœ„ ë°©ì‹ë“¤ ëª¨ë‘ Graph ê¸°ë°˜ì´ë¼ Adjacency matrixê°€ ë„ˆë¬´ ì»¤ì§. ì´ë¥¼ ì–´ì°Œí• ê¼¬..?


# ë„¤ì´ë²„ëŠ” Hybrid ì¶”ì²œì„ ì–´ë–»ê²Œ í• ê¹Œ?
- Hybrid ì¶”ì²œ: CB + CF
![[Pasted image 20250516104248.png]]

- CBë¥¼ ê°•í™”í•˜ê¸° ìœ„í•´ LLMìœ¼ë¡œ ìœ ì € ë¦¬ë·°ê¸€ì—ì„œ ê°€ê²Œ ì •ë³´ ì¶”ê°€

ì‹œê°í™”ë¥¼ ì•„ë˜ì™€ ê°™ì´ í•  ìˆ˜ ìˆìŒ.
- ì™¼ìª½ ê·¸ë¦¼: Contents based filtering ë§Œìœ¼ë¡œ ì„ë² ë”© í•œ ê²°ê³¼
- ì˜¤ë¥¸ìª½ ê·¸ë¦¼: Cb + Cfë¡œ ë¹„ê±´ ì‹ë‹¹ì´ ë³´ë‹¤ ê°€ê¹Œì›Œì§„ ëª¨ìŠµ.
![[Pasted image 20250516134308.png]]

ì•„ë˜ ì™¼ìª½ê·¸ë¦¼: CB filtering
ì˜¤ë¥¸ìª½ ê·¸ë¦¼: CB + CFë¡œ ì• ê²¬ ë™ë°˜ ì‹ë‹¹ì´ ë³´ë‹¤ ê°€ê¹Œì›Œì§„ ëª¨ìŠµ
![[Pasted image 20250516134433.png]]

ì„±ëŠ¥ ì¸¡ì •
Coverage: POI ìˆ˜
POISAGE: Pinsage ê¸°ìˆ ë¡œ, User - POI ê°„ Interaction ìˆëŠ” POIë§Œ ì‚¬ìš©
LLM: Text Featureì˜ ìœ ì‚¬ë„ë§Œìœ¼ë¡œ ì¶”ì²œ 
LLM + User Interaction: ê°€ì¥ ë†’ì€ ì„±ëŠ¥
![[Pasted image 20250516134623.png]]
```python
import torch
import torch.nn as nn
from torch_geometric.nn import LGConv

class LightGCNWithInteraction(nn.Module):
    def __init__(self, num_users, num_items, embed_dim, num_layers=3):
        super().__init__()
        self.user_embedding = nn.Embedding(num_users, embed_dim)
        self.item_embedding = nn.Embedding(num_items, embed_dim)
        self.brand_embedding = nn.Embedding(3, embed_dim)  # Nike, Adidas, Prospecs
        self.num_layers = num_layers
        self.conv = LGConv()

    def forward(self, edge_index, item_brand_ids, edge_weight=None):
        # embedding ì´ˆê¸°í™”
        x_user = self.user_embedding.weight                             # [num_users, D]
        x_item = self.item_embedding.weight + self.brand_embedding(item_brand_ids)  # [num_items, D]
        x = torch.cat([x_user, x_item], dim=0)                          # [num_users + num_items, D]

        # propagation
        all_embeddings = [x]
        for _ in range(self.num_layers):
            x = self.conv(x, edge_index, edge_weight)
            all_embeddings.append(x)

        x = sum(all_embeddings) / (self.num_layers + 1)
        user_embeddings = x[:x_user.size(0)]
        item_embeddings = x[x_user.size(0):]
        return user_embeddings, item_embeddings

class BPRLoss(nn.Module):
    def __init__(self, l2_reg=1e-4):
        super().__init__()
        self.l2_reg = l2_reg

    def forward(self, user_emb, pos_item_emb, neg_item_emb):
        pos_scores = (user_emb * pos_item_emb).sum(dim=1)
        neg_scores = (user_emb * neg_item_emb).sum(dim=1)

        loss = -torch.log(torch.sigmoid(pos_scores - neg_scores)).mean()

        # L2 ì •ê·œí™” (optional)
        l2 = (user_emb.norm(2).pow(2) +
              pos_item_emb.norm(2).pow(2) +
              neg_item_emb.norm(2).pow(2)) / user_emb.size(0)
        return loss + self.l2_reg * l2

def train(model, optimizer, bpr_loss_fn, edge_index, item_brand_ids, interactions, num_users, num_items, epochs=10):
    model.train()

    for epoch in range(epochs):
        total_loss = 0

        for (user_id, pos_item_id, _) in interactions:
            # ğŸ” forward ë¥¼ ì—¬ê¸°ì„œ ë‹¤ì‹œ
            user_emb_all, item_emb_all = model(edge_index, item_brand_ids)

            # ìŒì„± ìƒ˜í”Œë§
            while True:
                neg_item_id = torch.randint(0, num_items, (1,)).item()
                if (user_id, neg_item_id) not in [(u, i) for (u, i, _) in interactions]:
                    break

            u_emb = user_emb_all[user_id]
            pos_emb = item_emb_all[pos_item_id]
            neg_emb = item_emb_all[neg_item_id]

            loss = bpr_loss_fn(u_emb.unsqueeze(0), pos_emb.unsqueeze(0), neg_emb.unsqueeze(0))

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            total_loss += loss.item()

        print(f"Epoch {epoch+1:03d} | Loss: {total_loss:.4f}")

num_users = 3
num_items = 4
embed_dim = 16
item_brand_ids = torch.tensor([0, 1, 0, 2])  # 0:Nike, 1:Adidas, 2:Prospecs

# interactions = [(user, item, weight)]
interactions = [
    (0, 0, 1.0),
    (1, 2, 2.0),
    (2, 3, 1.0)
]

# edge_index, edge_weight
rows, cols, weights = [], [], []
for u, i, w in interactions:
    u_idx = u
    i_idx = num_users + i
    rows += [u_idx, i_idx]
    cols += [i_idx, u_idx]
    weights += [w, w]

edge_index = torch.tensor([rows, cols], dtype=torch.long)
edge_weight = torch.tensor(weights, dtype=torch.float)

# ëª¨ë¸, ì˜µí‹°ë§ˆì´ì €, Loss
model = LightGCNWithInteraction(num_users, num_items, embed_dim)
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
loss_fn = BPRLoss(l2_reg=1e-4)

# í•™ìŠµ
train(model, optimizer, loss_fn, edge_index, item_brand_ids, interactions, num_users, num_items, epochs=20)

# ì¶”ì²œ: user_idê°€ ì„ í˜¸í•  top-k ì•„ì´í…œ
def recommend(user_id, model, edge_index, item_brand_ids, top_k=3):
    model.eval()
    with torch.no_grad():
        user_embs, item_embs = model(edge_index, item_brand_ids)
        user_vec = user_embs[user_id]           # [D]
        scores = (user_vec * item_embs).sum(dim=1)  # [num_items]
        top_items = torch.topk(scores, top_k).indices
        return top_items.tolist()

# ì˜ˆì‹œ: ìœ ì € 0ì—ê²Œ ì¶”ì²œ
recommended = recommend(0, model, edge_index, item_brand_ids)
print("ì¶”ì²œ ì•„ì´í…œ:", recommended)

```